<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Relic Siege - 2D Browser Game</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b1020;
      --panel: #141c33;
      --accent: #66d9ef;
      --good: #59f39d;
      --warn: #ffcc66;
      --bad: #ff6b6b;
    }

    body {
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
      background: radial-gradient(circle at top, #1a2647 0%, #0b1020 60%);
      color: #e8edff;
      min-height: 100vh;
      display: grid;
      place-items: center;
    }

    .wrap {
      width: min(1100px, 96vw);
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 14px;
      align-items: start;
      margin: 20px 0;
    }

    canvas {
      width: 100%;
      height: auto;
      background: linear-gradient(180deg, #101937, #0c132a);
      border: 2px solid #2a3a6f;
      border-radius: 10px;
      box-shadow: 0 16px 40px rgba(0,0,0,.45);
    }

    .panel {
      background: rgba(20, 28, 51, 0.95);
      border: 1px solid #2a3a6f;
      border-radius: 10px;
      padding: 12px;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 22px;
      color: var(--accent);
    }

    .stat { margin: 8px 0; font-size: 14px; }
    .good { color: var(--good); }
    .warn { color: var(--warn); }
    .bad { color: var(--bad); }

    .controls { font-size: 13px; line-height: 1.4; opacity: 0.9; }

    button {
      width: 100%;
      margin-top: 10px;
      background: #2a3a6f;
      color: white;
      border: 0;
      padding: 10px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
    }

    button:hover { filter: brightness(1.12); }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="900" height="560"></canvas>
    <div class="panel">
      <h1>Relic Siege (2D)</h1>
      <div class="stat">Goal: finish <b>12 stages</b> (~25-35 min first run).</div>
      <div class="stat">Stage: <span id="stage">1</span> / 12</div>
      <div class="stat">Lives: <span id="lives" class="good">5</span></div>
      <div class="stat">Health: <span id="health" class="good">100</span></div>
      <div class="stat">Relics this stage: <span id="relics" class="warn">0 / 4</span></div>
      <div class="stat">Enemies left: <span id="enemies" class="bad">0</span></div>
      <div class="stat">Score: <span id="score">0</span></div>
      <hr style="border-color:#2a3a6f; opacity:.4" />
      <div class="controls">
        <b>Controls</b><br/>
        Move: WASD / Arrow keys<br/>
        Aim: Mouse<br/>
        Shoot: Left click (or hold)<br/>
        Dash: Space (short cooldown)<br/>
        Pause: P
      </div>
      <button id="restartBtn">Restart Run</button>
      <div class="stat" id="message" style="margin-top:12px; opacity:.95;"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const ui = {
      stage: document.getElementById('stage'),
      lives: document.getElementById('lives'),
      health: document.getElementById('health'),
      relics: document.getElementById('relics'),
      enemies: document.getElementById('enemies'),
      score: document.getElementById('score'),
      message: document.getElementById('message')
    };

    const W = canvas.width;
    const H = canvas.height;
    const TOTAL_STAGES = 12;

    let mouse = { x: W / 2, y: H / 2, down: false };
    let keys = new Set();
    let paused = false;

    function rand(min, max) { return Math.random() * (max - min) + min; }
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function makeGame() {
      return {
        stage: 1,
        score: 0,
        lives: 5,
        player: {
          x: W / 2,
          y: H / 2,
          r: 12,
          speed: 3.1,
          hp: 100,
          fireRateMs: 220,
          lastShot: 0,
          damage: 20,
          dashCooldown: 0,
          iframes: 0,
        },
        relicsNeeded: 4,
        relicsCollected: 0,
        relicItems: [],
        enemies: [],
        bullets: [],
        particles: [],
        stageStart: performance.now(),
        clearDelay: 0,
        gameOver: false,
        won: false,
      };
    }

    let game = makeGame();

    function spawnStage() {
      const g = game;
      g.relicItems = [];
      g.enemies = [];
      g.bullets = [];
      g.particles = [];
      g.relicsCollected = 0;
      g.relicsNeeded = 3 + Math.floor(g.stage / 3);
      g.stageStart = performance.now();
      g.clearDelay = 0;
      g.player.x = W / 2;
      g.player.y = H / 2;
      g.player.hp = Math.min(100, g.player.hp + 12);

      for (let i = 0; i < g.relicsNeeded; i++) {
        g.relicItems.push({ x: rand(40, W - 40), y: rand(40, H - 40), r: 10, taken: false });
      }

      const enemyCount = 8 + g.stage * 2;
      for (let i = 0; i < enemyCount; i++) {
        const edge = Math.floor(rand(0, 4));
        let x = 0, y = 0;
        if (edge === 0) { x = rand(0, W); y = -20; }
        if (edge === 1) { x = rand(0, W); y = H + 20; }
        if (edge === 2) { x = -20; y = rand(0, H); }
        if (edge === 3) { x = W + 20; y = rand(0, H); }
        g.enemies.push({
          x, y,
          r: rand(10, 16),
          hp: 25 + g.stage * 8,
          speed: rand(0.9, 1.5) + g.stage * 0.03,
          touchCd: 0,
        });
      }

      ui.message.textContent = `Stage ${g.stage}: collect relics and clear enemies.`;
    }

    function update(dtMs, now) {
      if (paused || game.gameOver || game.won) return;
      const g = game;
      const p = g.player;
      const dt = dtMs / 16.666;

      if (p.iframes > 0) p.iframes -= dtMs;
      if (p.dashCooldown > 0) p.dashCooldown -= dtMs;

      let dx = 0, dy = 0;
      if (keys.has('w') || keys.has('arrowup')) dy -= 1;
      if (keys.has('s') || keys.has('arrowdown')) dy += 1;
      if (keys.has('a') || keys.has('arrowleft')) dx -= 1;
      if (keys.has('d') || keys.has('arrowright')) dx += 1;
      const mag = Math.hypot(dx, dy) || 1;
      dx /= mag; dy /= mag;

      let speedBoost = 1;
      if ((keys.has(' ') || keys.has('space')) && p.dashCooldown <= 0) {
        speedBoost = 3.4;
        p.dashCooldown = 1800;
        p.iframes = 250;
      }

      p.x = clamp(p.x + dx * p.speed * speedBoost * dt, p.r, W - p.r);
      p.y = clamp(p.y + dy * p.speed * speedBoost * dt, p.r, H - p.r);

      if (mouse.down && now - p.lastShot > p.fireRateMs) {
        const ax = mouse.x - p.x;
        const ay = mouse.y - p.y;
        const m = Math.hypot(ax, ay) || 1;
        g.bullets.push({
          x: p.x,
          y: p.y,
          vx: (ax / m) * 8.5,
          vy: (ay / m) * 8.5,
          life: 1400,
          dmg: p.damage,
          r: 4,
        });
        p.lastShot = now;
      }

      for (const b of g.bullets) {
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.life -= dtMs;
      }
      g.bullets = g.bullets.filter(b => b.life > 0 && b.x > -20 && b.x < W + 20 && b.y > -20 && b.y < H + 20);

      for (const e of g.enemies) {
        const ax = p.x - e.x;
        const ay = p.y - e.y;
        const m = Math.hypot(ax, ay) || 1;
        e.x += (ax / m) * e.speed * dt;
        e.y += (ay / m) * e.speed * dt;
        if (e.touchCd > 0) e.touchCd -= dtMs;
      }

      // Bullet hits
      for (const b of g.bullets) {
        for (const e of g.enemies) {
          if (Math.hypot(b.x - e.x, b.y - e.y) < b.r + e.r) {
            e.hp -= b.dmg;
            b.life = 0;
            g.particles.push({ x: e.x, y: e.y, t: 220 });
            break;
          }
        }
      }

      // Enemy contact
      for (const e of g.enemies) {
        if (Math.hypot(p.x - e.x, p.y - e.y) < p.r + e.r + 2 && e.touchCd <= 0 && p.iframes <= 0) {
          const hit = 8 + Math.floor(g.stage / 2);
          p.hp -= hit;
          e.touchCd = 650;
          p.iframes = 300;
          g.particles.push({ x: p.x, y: p.y, t: 300, bad: true });
        }
      }

      // Pick relics
      for (const r of g.relicItems) {
        if (!r.taken && Math.hypot(p.x - r.x, p.y - r.y) < p.r + r.r + 2) {
          r.taken = true;
          g.relicsCollected += 1;
          g.score += 100;
          p.hp = Math.min(100, p.hp + 4);
          g.particles.push({ x: r.x, y: r.y, t: 380 });
        }
      }

      g.enemies = g.enemies.filter(e => {
        if (e.hp > 0) return true;
        g.score += 20;
        if (Math.random() < 0.08) {
          p.hp = Math.min(100, p.hp + 8);
        }
        return false;
      });

      g.particles = g.particles.filter(pt => (pt.t -= dtMs) > 0);

      // Lose life
      if (p.hp <= 0) {
        g.lives -= 1;
        if (g.lives <= 0) {
          g.gameOver = true;
          ui.message.textContent = 'Game Over. Restart and try again.';
          return;
        }
        p.hp = 100;
        p.x = W / 2;
        p.y = H / 2;
        p.iframes = 1200;
        ui.message.textContent = `You lost a life! ${g.lives} left.`;
      }

      // Stage clear
      const allRelics = g.relicsCollected >= g.relicsNeeded;
      const allEnemies = g.enemies.length === 0;
      if (allRelics && allEnemies) {
        g.clearDelay += dtMs;
        if (g.clearDelay > 900) {
          g.stage += 1;
          g.player.damage += 2;
          g.player.fireRateMs = Math.max(120, g.player.fireRateMs - 6);
          g.player.speed = Math.min(4.2, g.player.speed + 0.05);

          if (g.stage > TOTAL_STAGES) {
            g.won = true;
            ui.message.textContent = 'You won the full run. Nice.';
            return;
          }
          spawnStage();
        }
      }

      ui.stage.textContent = g.stage;
      ui.lives.textContent = g.lives;
      ui.health.textContent = Math.max(0, Math.floor(g.player.hp));
      ui.relics.textContent = `${g.relicsCollected} / ${g.relicsNeeded}`;
      ui.enemies.textContent = g.enemies.length;
      ui.score.textContent = g.score;
    }

    function draw() {
      const g = game;
      ctx.clearRect(0, 0, W, H);

      // Grid
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = '#4f6ab8';
      for (let x = 0; x < W; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for (let y = 0; y < H; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }
      ctx.restore();

      // Relics
      for (const r of g.relicItems) {
        if (r.taken) continue;
        ctx.beginPath();
        ctx.fillStyle = '#ffd166';
        ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff5c3';
        ctx.stroke();
      }

      // Enemies
      for (const e of g.enemies) {
        ctx.beginPath();
        ctx.fillStyle = '#ff5f7a';
        ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
        ctx.fill();
        // hp bar
        ctx.fillStyle = 'rgba(0,0,0,.45)';
        ctx.fillRect(e.x - 18, e.y - e.r - 12, 36, 5);
        ctx.fillStyle = '#69f0a8';
        const hpPct = clamp(e.hp / (25 + g.stage * 8), 0, 1);
        ctx.fillRect(e.x - 18, e.y - e.r - 12, 36 * hpPct, 5);
      }

      // Bullets
      for (const b of g.bullets) {
        ctx.beginPath();
        ctx.fillStyle = '#8ef1ff';
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fill();
      }

      // Player
      ctx.beginPath();
      ctx.fillStyle = g.player.iframes > 0 ? '#8fe3ff' : '#66d9ef';
      ctx.arc(g.player.x, g.player.y, g.player.r, 0, Math.PI * 2);
      ctx.fill();

      // Aim line
      ctx.strokeStyle = 'rgba(102,217,239,0.4)';
      ctx.beginPath();
      ctx.moveTo(g.player.x, g.player.y);
      ctx.lineTo(mouse.x, mouse.y);
      ctx.stroke();

      // Particles
      for (const pt of g.particles) {
        ctx.beginPath();
        ctx.globalAlpha = clamp(pt.t / 380, 0, 1);
        ctx.fillStyle = pt.bad ? '#ff9aa7' : '#f6e58d';
        ctx.arc(pt.x, pt.y, 4 + (1 - pt.t / 380) * 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // Messages overlay
      if (paused) {
        overlay('PAUSED');
      } else if (g.gameOver) {
        overlay('GAME OVER');
      } else if (g.won) {
        overlay('YOU WON');
      }
    }

    function overlay(text) {
      ctx.fillStyle = 'rgba(0,0,0,.45)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = 'white';
      ctx.font = 'bold 56px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(text, W / 2, H / 2);
      ctx.font = '20px Arial';
      ctx.fillText('Press Restart to play again', W / 2, H / 2 + 34);
      ctx.textAlign = 'start';
    }

    let last = performance.now();
    function tick(now) {
      const dt = now - last;
      last = now;
      update(dt, now);
      draw();
      requestAnimationFrame(tick);
    }

    window.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if ([" ", "arrowup", "arrowdown", "arrowleft", "arrowright"].includes(k)) e.preventDefault();
      if (k === 'p') {
        paused = !paused;
        ui.message.textContent = paused ? 'Paused.' : 'Resumed.';
      } else {
        keys.add(k);
      }
    });

    window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

    canvas.addEventListener('mousemove', (e) => {
      const r = canvas.getBoundingClientRect();
      mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
      mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
    });
    canvas.addEventListener('mousedown', () => (mouse.down = true));
    window.addEventListener('mouseup', () => (mouse.down = false));

    document.getElementById('restartBtn').addEventListener('click', () => {
      game = makeGame();
      spawnStage();
      paused = false;
      ui.message.textContent = 'Fresh run started.';
    });

    spawnStage();
    requestAnimationFrame(tick);
  </script>
</body>
</html>
